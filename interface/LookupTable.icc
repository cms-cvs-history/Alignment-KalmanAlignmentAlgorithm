#ifndef Alignment_KalmanAlignmentAlgorithm_LookupTable_icc
#define Alignment_KalmanAlignmentAlgorithm_LookupTable_icc

#include "Alignment/KalmanAlignmentAlgorithm/interface/LookupTable.h"


template< class Ti, class Tv >
map< Ti, Tv > LookupTable< Ti, Tv >::getColumn( Ti J )
{
  map< Ti, Tv > theColumn;
  typename map< Ti, map< Ti, Tv > >::iterator itT;
  typename map< Ti, Tv >::iterator itS;
  for ( itT = theTable.begin(); itT != theTable.end(); itT++ )
  {
    itS = ( itT->second ).find( J );
    if ( itS != ( itT->second ).end() ) theColumn[itT->first] = itS->second;
  }
  return theColumn;
}


template< class Ti, class Tv >
void LookupTable< Ti, Tv >::setRow( Ti & I, map< Ti, Tv > & row, bool eraseOldRow )
{
  eraseOldRow ? eraseOldAndSetNewRow( I, row ) : setNewRowElements( I, row );
}


template< class Ti, class Tv >
void LookupTable< Ti, Tv >::eraseOldAndSetNewRow( Ti & I, map< Ti, Tv > & row )
{
  theTable[I] = row;
}


template< class Ti, class Tv >
void LookupTable< Ti, Tv >::setNewRowElements( Ti & I, map< Ti, Tv > & row )
{
  typename map< Ti, Tv >::iterator itR;
  for ( itR = row.begin(); itR != row.end(); itR++ )
  {
    theTable[I][itR->first] = itR->second;
  }
}


template< class Ti, class Tv >
void LookupTable< Ti, Tv >::setColumn( Ti & J, map< Ti, Tv > & col, bool eraseOldColumn )
{
  eraseOldColumn ? eraseOldAndSetNewColumn( J, col ) : setNewColumnElements( J, col );
}


template< class Ti, class Tv >
void LookupTable< Ti, Tv >::eraseOldAndSetNewColumn( Ti & J, map< Ti, Tv > & col )
{
  typename map< Ti, map< Ti, Tv > >::iterator itT;
  for ( itT = theTable.begin(); itT != theTable.end(); itT++ )
  {
    if ( col.find( itT->first ) != col.end() )
    {
      ( itT->second ) [J] = col [itT->first];
    }
    else if ( ( itT->second ).find( J ) != ( itT->second ).end() )
    {
      ( itT->second ).erase( ( itT->second ).find( J ) );
    }
  }
}

template< class Ti, class Tv >
void LookupTable< Ti, Tv >::setNewColumnElements( Ti & J, map< Ti, Tv > & col )
{
  typename map< Ti, map< Ti, Tv > >::iterator itT;
  for ( itT = theTable.begin(); itT != theTable.end(); itT++ )
  {
    if ( col.find( itT->first ) != col.end() ) ( itT->second ) [J] = col [itT->first];
  }
}


template< class Ti, class Tv >
void LookupTable< Ti, Tv >::print( void )
{
  typename map< Ti, map< Ti, Tv > >::iterator itT;
  typename map< Ti, Tv >::iterator itS;
  for ( itT = theTable.begin(); itT != theTable.end(); itT++ )
  {
    for ( itS = (itT->second).begin(); itS != (itT->second).end(); itS++ )
    {
      cout << itS->second << "\t";
    }
    cout << endl;
  }
  cout << endl;
}


template< class Ti, class Tv >
struct add_to_positive_data : public unary_function< pair< Ti, Tv >, void >
{
  add_to_positive_data( Tv q ) : summand( q ) {}
  void operator() ( pair< Ti, Tv > & p ) { if ( p.second >= 0 ) p.second = p.second + summand; }
  Tv summand;
};

#endif // LookupTable_ICC
