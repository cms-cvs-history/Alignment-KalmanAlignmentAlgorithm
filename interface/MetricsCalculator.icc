#ifndef Alignment_KalmanAlignmentAlgorithm_MetricsCalculator_icc
#define Alignment_KalmanAlignmentAlgorithm_MetricsCalculator_icc

#include "Alignment/KalmanAlignmentAlgorithm/interface/MetricsCalculator.h"

#include <set>
#include <algorithm>
#include <functional>
#include <limits>

using namespace std;


template< class DetIndex>
MetricsCalculator< DetIndex >::MetricsCalculator()
{
  theMaxDistance = numeric_limits< int >::max();
}


template< class DetIndex>
MetricsCalculator< DetIndex >::~MetricsCalculator() {}


template< class DetIndex>
void MetricsCalculator< DetIndex >::computeDistances( vector< DetIndex > theHits )
{
  typename vector< DetIndex >::iterator itI;
  typename vector< DetIndex >::iterator itJ;

  vector< map< DetIndex, int > > newRows;
  typename vector< map< DetIndex, int > >::iterator itnRs;
  map< DetIndex, int > oldRow;
  typename map< DetIndex, int >::iterator itoR;
  typename map< DetIndex, int >::iterator itnR;
  typename map< DetIndex, int >::iterator itdel;

  for ( itI = theHits.begin(); itI != theHits.end(); itI++ )
  {
    for ( itJ = theHits.begin(); itJ != theHits.end(); itJ++ )
    {
      theMetricsTable( *itI, *itJ ) = 0;
    }
    newRows.push_back( theMetricsTable.getRow( *itI ) );
  }

  for ( itnRs = newRows.begin(); itnRs != newRows.end(); itnRs++ )
  {
    for ( itI = theHits.begin(); itI != theHits.end(); itI++ )
    {
      oldRow = theMetricsTable.getRow( *itI );

      map< DetIndex, int > temp = (*itnRs);

      for ( itnR = (*itnRs).begin(), itoR = oldRow.begin(); itoR != oldRow.end(); )
      {
	if ( itnR->first < itoR->first ) {
	  itnR++;
	} else if ( itnR->first == itoR->first ) {
	  if ( itnR->second > itoR->second ) temp[itoR->first] = itoR->second + 1;
	  itnR++;
	  itoR++;
	} else {
	  temp[itoR->first] = itoR->second + 1;
	  itoR++;
	}

	if ( itnR == (*itnRs).end() )
	{
	  for ( ; itoR != oldRow.end(); itoR++ )
	  {
	    temp[itoR->first] = itoR->second + 1;
	  }
	}
      }

      (*itnRs) = temp;
    }
  }

  for ( itI = theHits.begin(), itnRs = newRows.begin(); ( itI != theHits.end() ) && ( itnRs != newRows.end() ); itI++, itnRs++ )
  {
    for ( itnR = (*itnRs).begin(); itnR != (*itnRs).end(); )
    {
      if ( itnR->second > theMaxDistance )
      {
	itdel = itnR;
	itnR++;
	(*itnRs).erase( itdel );
      } else {
	itnR++;
      }
    }
    theMetricsTable.setRow( *itI, *itnRs, true );
    theMetricsTable.setColumn( *itI, *itnRs, true );
  }
}


template< class DetIndex>
int MetricsCalculator< DetIndex >::nElements( void )
{
  typename map< DetIndex, map< DetIndex, int > >::iterator itR;
  typename map< DetIndex, int >::iterator itC;

  int N = 0;

  for ( itR = theMetricsTable.begin(); itR != theMetricsTable.end(); itR++ )
  {
    for ( itC = (itR->second).begin(); itC != (itR->second).end(); itC++ )
    {
      N++;
    }
  }

  return N;
}


#endif
